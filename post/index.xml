<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on HuangJacky技术分享</title>
    <link>http://huangjacky.github.io/post/</link>
    <description>Recent content in Posts on HuangJacky技术分享</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 18 Feb 2016 19:12:06 +0800</lastBuildDate>
    <atom:link href="http://huangjacky.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>NFC安全的探讨</title>
      <link>http://huangjacky.github.io/post/nfc-security-1/</link>
      <pubDate>Thu, 18 Feb 2016 19:12:06 +0800</pubDate>
      
      <guid>http://huangjacky.github.io/post/nfc-security-1/</guid>
      <description>

&lt;h2 id=&#34;0x1-nfc介绍:b46d1cdc865ed3206ad6adb582745f39&#34;&gt;0x1 NFC介绍&lt;/h2&gt;

&lt;p&gt;NFC的全称是Near Field Communication，中文名称叫做近场通讯，它是基于RFID技术的一种短距高频的无线技术，工作频率主要集中在13.56MHz&lt;/p&gt;

&lt;h2 id=&#34;0x5-参考:b46d1cdc865ed3206ad6adb582745f39&#34;&gt;0x5 参考&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;1&#34;&gt;near field communication&lt;/a&gt;
2.
[1] &lt;a href=&#34;http://www.nearfieldcommunication.org/nfc-security.html&#34;&gt;http://www.nearfieldcommunication.org/nfc-security.html&lt;/a&gt; &amp;ldquo;NFC Security&amp;rdquo;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>scikit-learn的学习笔记 1</title>
      <link>http://huangjacky.github.io/post/scikitlearn-1/</link>
      <pubDate>Thu, 18 Feb 2016 18:27:15 +0800</pubDate>
      
      <guid>http://huangjacky.github.io/post/scikitlearn-1/</guid>
      <description>

&lt;h2 id=&#34;如何使用scikit-learn进行机器学习:6aea5f4659458d5da76002eca2a05fb1&#34;&gt;如何使用scikit-learn进行机器学习&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>我的Python机器学习笔记.1</title>
      <link>http://huangjacky.github.io/post/python-machinelearn1/</link>
      <pubDate>Sun, 14 Feb 2016 20:15:16 +0800</pubDate>
      
      <guid>http://huangjacky.github.io/post/python-machinelearn1/</guid>
      <description>

&lt;h2 id=&#34;0x1-机器学习的分类:439a07facb543f750f6ac56cbaeeb58f&#34;&gt;0x1 机器学习的分类&lt;/h2&gt;

&lt;p&gt;机器学习主要分成：
1. 监督学习 supervised learning
2. 无监督学习 unsupervised learning
3. 强化学习 enforcement learning&lt;/p&gt;

&lt;h3 id=&#34;机器学习的算法和用途:439a07facb543f750f6ac56cbaeeb58f&#34;&gt;机器学习的算法和用途&lt;/h3&gt;

&lt;h4 id=&#34;监督学习:439a07facb543f750f6ac56cbaeeb58f&#34;&gt;监督学习：&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;k-邻近算法  线性回归&lt;/li&gt;
&lt;li&gt;朴素贝叶斯算法  局部加权线性回归&lt;/li&gt;
&lt;li&gt;支持向量机  ridge回归&lt;/li&gt;
&lt;li&gt;决策树  lasso最小回归系数估计&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;无监督学习:439a07facb543f750f6ac56cbaeeb58f&#34;&gt;无监督学习：&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;k-均值  最大期望算法&lt;/li&gt;
&lt;li&gt;DBSCAN  parzen窗设计&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;如何选择合适的算法:439a07facb543f750f6ac56cbaeeb58f&#34;&gt;如何选择合适的算法&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;考虑机器学习算法的目的&lt;/li&gt;
&lt;li&gt;确定目标变量的类型，离散型选择分类，连续值选择线性回归&lt;/li&gt;
&lt;li&gt;考虑数据问题，已知样本是否充足等&lt;/li&gt;
&lt;li&gt;没有最好的算法，因此在运行过程中，要运行不同算法来评估学习模型&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;机器学习应用程序的步骤:439a07facb543f750f6ac56cbaeeb58f&#34;&gt;机器学习应用程序的步骤&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;收集数据&lt;br /&gt;
必要时为了节约时间可以直接使用公开的已有数据。&lt;/li&gt;
&lt;li&gt;输入数据&lt;br /&gt;
数据的格式要满足算法的需要，因此有时候需要转换格式。&lt;/li&gt;
&lt;li&gt;分析数据&lt;br /&gt;
人工分析数据有无异常，同时可以采用一维，二维和三维的图形来直观观察。&lt;/li&gt;
&lt;li&gt;训练算法&lt;br /&gt;
将格式化的数据通过学习算法来提取知识或信息，并存储，以便后续步骤使用。无监督学习不需要这一步。&lt;/li&gt;
&lt;li&gt;测试算法&lt;br /&gt;
使用测试数据样本来评估算法实际能力，如果不满意，分析原因要么重新选择算法，要么重新收集数据。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用算法&lt;br /&gt;
将机器学习算法转换成应用程序，投入到实际任务中，如果实际中还有问题数据，需要重复以上步骤。&lt;/p&gt;

&lt;h2 id=&#34;0x2-python机器学习相关库:439a07facb543f750f6ac56cbaeeb58f&#34;&gt;0x2 Python机器学习相关库&lt;/h2&gt;

&lt;h3 id=&#34;安装:439a07facb543f750f6ac56cbaeeb58f&#34;&gt;安装&lt;/h3&gt;

&lt;p&gt;有网络的情况下，安装这些库都是非常简单的事。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;pip install numpy scipy matplotlib pandas scikit-learn
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;numpy&lt;/strong&gt;中又数组array和矩阵matrix两种数据类型，数据相似，但是是不同的类型，同样的运算符可能得到不同的结果。&lt;strong&gt;mat()&lt;/strong&gt;函数可以将数组转换成矩阵类型。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from numpy import *
m = mat(random.rand(4,4))
c = m.I * m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;矩阵的运算，numpy内部数据采用c语言数据结构，更紧凑高效。&lt;/p&gt;

&lt;h2 id=&#34;0x3-k-邻近算法:439a07facb543f750f6ac56cbaeeb58f&#34;&gt;0x3 k-邻近算法&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;精度高，对异常数据不敏感，无数据输入假定&lt;br /&gt;
&lt;strong&gt;缺点：&lt;/strong&gt;计算复杂度和空间复杂度高&lt;br /&gt;
&lt;strong&gt;适用数据范围：&lt;/strong&gt;数值型和标称型&lt;br /&gt;
&lt;strong&gt;工作原理：&lt;/strong&gt;训练样本中的数据都已经分类且知道特征和分类之间的对应关系，当未知分类数据时，算法提取样本集中选择K个最相似数据的分类标签，然后从K个标签中选择出现次数最多的哪个标签作为预测值，一般K不超过20。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>expect脚本入门</title>
      <link>http://huangjacky.github.io/post/expect-usage/</link>
      <pubDate>Sun, 14 Feb 2016 13:31:43 +0800</pubDate>
      
      <guid>http://huangjacky.github.io/post/expect-usage/</guid>
      <description>

&lt;h2 id=&#34;0x1-什么是expect:1f8f1ad3647c9c17632c3f1db7ef7962&#34;&gt;0x1 什么是expect&lt;/h2&gt;

&lt;p&gt;有时候我们需要自动完成一系列的名单，但是这些命令需要交互，比如SSH，需要人工输入密码，这个时候我们可以写一个expect脚本来完成这些任务。&lt;br /&gt;
expect被运用在大多数的运维脚本上，当然很多编程语言里面也提供相应的封装库，比如Python中的&lt;a href=&#34;https://pypi.python.org/pypi/pexpect/4.0.1&#34; title=&#34;Python pexpect&#34;&gt;pexpect&lt;/a&gt;，PHP中的expect://伪协议以及&lt;a href=&#34;http://php.net/manual/zh/function.expect-expectl.php&#34; title=&#34;PHP expect-expectl&#34;&gt;expect_expectl函数&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;0x2-expect脚本入门讲解:1f8f1ad3647c9c17632c3f1db7ef7962&#34;&gt;0x2 expect脚本入门讲解&lt;/h2&gt;

&lt;p&gt;一个expect脚本可以有两种形式，第一种直接使用expect解析。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/usr/bin/expect
# code here
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另一种是使用expect -c 来直接执行expect的字符串命令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/bash
/usr/bin/expect -c &amp;quot;code here&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两种形式，各位看官老爷自己选择吧。&lt;/p&gt;

&lt;h2 id=&#34;0x3-expect重要的命令讲解:1f8f1ad3647c9c17632c3f1db7ef7962&#34;&gt;0x3 expect重要的命令讲解&lt;/h2&gt;

&lt;h3 id=&#34;输出回显:1f8f1ad3647c9c17632c3f1db7ef7962&#34;&gt;输出回显&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;send &amp;quot;abc\n&amp;quot;
send_user &amp;quot;dddd\n&amp;quot;
puts stdout|stderr &amp;quot;ererer\n&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;目前主要使用如上三个命令。&lt;/p&gt;

&lt;h3 id=&#34;执行命令:1f8f1ad3647c9c17632c3f1db7ef7962&#34;&gt;执行命令&lt;/h3&gt;

&lt;p&gt;一些常见的命令比如cd(切换工作目录)，可以直接执行，其他的命令需要使用exec来运行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd public
exec /usr/local/bin/git add -A
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里需要注意的地方就是最好带上命令的完整路径。&lt;/p&gt;

&lt;h3 id=&#34;执行需要交互的命令:1f8f1ad3647c9c17632c3f1db7ef7962&#34;&gt;执行需要交互的命令&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;spawn /usr/local/bin/git push
expect {
  &amp;quot;Username&amp;quot; {send &amp;quot;huangjacky\n&amp;quot;; exp_continue;}
  &amp;quot;*assword&amp;quot; {send &amp;quot;test\n&amp;quot;}
}
expect &amp;quot;in \d+ ms&amp;quot;
send &amp;quot;ok\n&amp;quot;
expect eof
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面例子中使用&lt;strong&gt;spawn&lt;/strong&gt;来执行需要交互的命名。使用&lt;strong&gt;expect&lt;/strong&gt;来匹配命令执行后的回显，参数可以是一个字符串，也可以在里面使用通配符，还可以是一个正则。输入数据和命令使用&lt;strong&gt;send&lt;/strong&gt;，其中使用\n来表示回车键。&lt;br /&gt;
当需要判断多个输出的时候使用{}括起来，expect和{}中间有个空格一定不能少，正常情况来说{}里面所有匹配条件只有一个能够被执行，如果需要循环执行，使用&lt;strong&gt;exp_continue&lt;/strong&gt;来再次进入本次匹配。&lt;br /&gt;
使用&lt;strong&gt;expect eof&lt;/strong&gt;来判断进程是否执行完毕。&lt;/p&gt;

&lt;h3 id=&#34;变量赋值和参数获取:1f8f1ad3647c9c17632c3f1db7ef7962&#34;&gt;变量赋值和参数获取&lt;/h3&gt;

&lt;p&gt;expect中一些内置变量&lt;strong&gt;$argv&lt;/strong&gt;是参数数组，0是第一个参数，文件本身不在这个数组中，而单独的变量&lt;strong&gt;$argv0&lt;/strong&gt;才是是文件本身的路径，&lt;strong&gt;$argc&lt;/strong&gt;是参数的数量，&lt;strong&gt;timeout&lt;/strong&gt;是spawn执行命令超时设置，单位秒，0是不超时，一致等待到expect匹配成功。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;set timeout 30
set name [lindex $argv 0]
set cdir [exec pwd]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;判断条件:1f8f1ad3647c9c17632c3f1db7ef7962&#34;&gt;判断条件&lt;/h3&gt;

&lt;p&gt;expect中的判断条件使用{}括起来，执行语句也使用{}括起来。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;if {$argc!=0} {
  puts stderr &amp;quot;Usage: $argv0 msg\n&amp;quot;
  exit
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;条件的{}和执行语句{}之间必须有一个空间，判断条件的左值和右值以及逻辑运算符之间不能有空格。&lt;br /&gt;
大致语法和shell脚本差不多。&lt;/p&gt;

&lt;h2 id=&#34;0x4-参考:1f8f1ad3647c9c17632c3f1db7ef7962&#34;&gt;0x4 参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;[1] &lt;a href=&#34;http://linux.die.net/man/1/expect&#34; title=&#34;expect手册&#34;&gt;expect手册&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[2] &lt;a href=&#34;http://dongweiming.github.io/blog/archives/%E5%85%B3%E4%BA%8Eexpect%E7%A0%94%E7%A9%B6%EF%BC%88%E4%BA%8C%EF%BC%89/&#34; title=&#34;expect研究&#34;&gt;expect研究二&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>PHP安全开发规范</title>
      <link>http://huangjacky.github.io/post/docs-php-secure-coding/</link>
      <pubDate>Sat, 13 Feb 2016 20:36:09 +0800</pubDate>
      
      <guid>http://huangjacky.github.io/post/docs-php-secure-coding/</guid>
      <description>

&lt;h2 id=&#34;0x1-编写目的:bde8b6622ae197dc427e7081335654b0&#34;&gt;0x1 编写目的&lt;/h2&gt;

&lt;p&gt;本文主要针对PHP开发者，结合PHP语言的一些特性，在开发过程可能出现安全问题的地方和一些常见修复建议或者安全策略。&lt;/p&gt;

&lt;h2 id=&#34;0x2-php语言特性:bde8b6622ae197dc427e7081335654b0&#34;&gt;0x2 PHP语言特性&lt;/h2&gt;

&lt;p&gt;PHP是目前市面上最流行的服务端编程语言，被用于各种网站后台开发。作为一款开源软件，它拥有庞大的开源社区，丰富的优秀三方库和框架，为开发者提供极大的便利。因此讲述PHP安全开发规范的时候，我们需要考虑以上三个方面：编程语言本身，框架，库。&lt;br /&gt;
PHP的变量是&lt;strong&gt;弱类型&lt;/strong&gt;，变量的类型会根据数据自动变化。这个特性会导致一些开发者不易察觉的错误或者插入一些无法预期的数据。
PHP对于异常的处理也比较奇妙，当有错误发生的时候，程序一般会打印异常，但是程序的流程并不会中断，那么程序的运行结果也是无法预估。有如下代码，判断用户是否在黑名单中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-PHP&#34;&gt;$db_link = mysqli_connect(&#39;localhost&#39;, &#39;dbuser&#39;, &#39;dbpassword&#39;, &#39;dbname&#39;);
function can_access_feature($current_user) {
       global $db_link;
       $username = mysqli_real_escape_string($db_link, $current_user-&amp;gt;username);
       $res = mysqli_query($db_link, &amp;quot;SELECT COUNT(id) FROM blacklisted_users WHERE username = &#39;$username&#39;;&amp;quot;);
       $row = mysqli_fetch_array($res);
       if ((int)$row[0] &amp;gt; 0) {
           return false;
       } else {
           return true;
       }
   }
  if (!can_access_feature($current_user)) {
          exit();
  }
  //其他的逻辑    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果密码错误，数据库连接就会失败，&lt;strong&gt;$db_link&lt;/strong&gt;就是null，但是程序还会继续运行，那么&lt;strong&gt;$row&lt;/strong&gt;也会是null，因此&lt;strong&gt;(int)$row[0]&lt;/strong&gt;同样是null，也就等于0，函数根本就没有查询数据库中的黑名单就将访问权限开放给任意用户了，业务逻辑完全被绕过。
PHP的一些内置函数，看上去有过滤，但是实际上对于安全没有任何帮助，例如：&lt;strong&gt;addslashes&lt;/strong&gt;, &lt;strong&gt;mysql_escape_string&lt;/strong&gt;,&lt;strong&gt;mysql_real_escape_string&lt;/strong&gt;，这类函数基本上都容易被绕过，也是PHP将要淘汰的函数。&lt;/p&gt;

&lt;h2 id=&#34;0x3-常见漏洞:bde8b6622ae197dc427e7081335654b0&#34;&gt;0x3 常见漏洞&lt;/h2&gt;

&lt;h3 id=&#34;0x3-1-xss跨站脚本:bde8b6622ae197dc427e7081335654b0&#34;&gt;0x3.1 XSS跨站脚本&lt;/h3&gt;

&lt;p&gt;XSS漏洞是最常见的Web漏洞。&lt;/p&gt;

&lt;h3 id=&#34;0x3-2-injection注入攻击:bde8b6622ae197dc427e7081335654b0&#34;&gt;0x3.2 Injection注入攻击&lt;/h3&gt;

&lt;p&gt;注入攻击主要包括代码执行和SQL注入。&lt;/p&gt;

&lt;h3 id=&#34;0x3-3-include文件包含:bde8b6622ae197dc427e7081335654b0&#34;&gt;0x3.3 Include文件包含&lt;/h3&gt;

&lt;p&gt;文件包含可能存在严重的信息泄露导致，服务器安全受到危害。&lt;/p&gt;

&lt;h3 id=&#34;0x3-4-逻辑漏洞:bde8b6622ae197dc427e7081335654b0&#34;&gt;0x3.4 逻辑漏洞&lt;/h3&gt;

&lt;h2 id=&#34;0x4-安全建议:bde8b6622ae197dc427e7081335654b0&#34;&gt;0x4 安全建议&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;理解功能需求，规划接口和参数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;开发人员在编写代码之前要理解功能需求，知道要完成功能是什么，将功能划分成CGI接口，然后整理CGI需要的参数，形成一个参数列表，然后列出各个参数的约束条件。   比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;接口setUsername
参数列表：
$id int
$name &#39;/^[a-z0-9]+$/i&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的例子表明接口&lt;strong&gt;setUsername&lt;/strong&gt;需要两个参数，其中&lt;strong&gt;$id&lt;/strong&gt;的约束条件是必须为整数，&lt;strong&gt;$name&lt;/strong&gt;的约束条件是只能是数字和英文字符，经过这样校验的参数不管用于页面输出，还是存入数据库都不会对系统造成损害。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;统一入口，进行安全检测，以防遗漏&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;目前多数的框架都是用统一入口，由index.php进行路由转发，其他php文件均无法直接访问。借助这个思想，我们可以将上述的安全检测放置在统一入口的路由转发之前，当参数无法满足参数列表中的要求，程序流程直接结束。&lt;br /&gt;
同时程序可以将参数-约束条件列表独立成配置文件，这样以后增加参数或者修改约束条件都不需要在修改源码，将安全检测和业务逻辑完全分开，并且可以配置。&lt;br /&gt;
具体的检测逻辑的代码可以参考开源项目&lt;a href=&#34;http://git.oschina.net/huangjacky/Security-CI/blob/master/system/helpers/check_helper.php&#34; title=&#34;Security-CI示例代码&#34;&gt;Security-CI&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;0x5-参考:bde8b6622ae197dc427e7081335654b0&#34;&gt;0x5 参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;[1] &lt;a href=&#34;https://www.owasp.org/index.php/PHP_Security_Cheat_Sheet&#34; title=&#34;OWASP PHP安全手册&#34;&gt;OWASP PHP安全手册&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>安全开发规范概要</title>
      <link>http://huangjacky.github.io/post/general/</link>
      <pubDate>Sat, 13 Feb 2016 18:14:49 +0800</pubDate>
      
      <guid>http://huangjacky.github.io/post/general/</guid>
      <description>

&lt;h2 id=&#34;0x1-编写目的:af64df5535833d56354a810c9b55c190&#34;&gt;0x1 编写目的&lt;/h2&gt;

&lt;p&gt;本文主要阐述开发过程中需要注意的安全原则，和编程语言没有关系，本文并不会对相关原则展开进行详讲解。后续将会在具体的编程语言安全开发规范中做进一步，更详细的描述。&lt;/p&gt;

&lt;h2 id=&#34;0x2-十大安全编程原则:af64df5535833d56354a810c9b55c190&#34;&gt;0x2 十大安全编程原则&lt;/h2&gt;

&lt;h3 id=&#34;1-输入验证:af64df5535833d56354a810c9b55c190&#34;&gt;1. 输入验证&lt;/h3&gt;

&lt;p&gt;所有从不可控输入源传递的数据都需要进行安全验证，有效的安全验证可以避免绝大多数的安全漏洞。&lt;/p&gt;

&lt;h3 id=&#34;2-警示编译器警告:af64df5535833d56354a810c9b55c190&#34;&gt;2. 警示编译器警告&lt;/h3&gt;

&lt;p&gt;警告可能不会影响程序的编译，但是却会留下安全隐患和不确定的因素。一些非编译语言也需要相关linter来检测编码是否符合开发规范。因此在开发的过程中，需要使用静态源码分析工具来不断提高代码的质量。&lt;/p&gt;

&lt;h3 id=&#34;3-针对安全策略的架构和设计:af64df5535833d56354a810c9b55c190&#34;&gt;3. 针对安全策略的架构和设计&lt;/h3&gt;

&lt;p&gt;安全越早接入到开发过程中，会使得防御工作更轻松，系统更可靠，更不容易被攻击。&lt;br /&gt;
在开发周期的早期就确定并文档记录系统安全需求，确保后续的开发都符合安全需求并能通过安全评估。&lt;/p&gt;

&lt;h3 id=&#34;4-保持简单性:af64df5535833d56354a810c9b55c190&#34;&gt;4. 保持简单性&lt;/h3&gt;

&lt;p&gt;功能设计的时候，模块越小，逻辑越清晰，能够有效减少犯错的可能性。&lt;/p&gt;

&lt;h3 id=&#34;5-默认拒绝:af64df5535833d56354a810c9b55c190&#34;&gt;5. 默认拒绝&lt;/h3&gt;

&lt;p&gt;所有的访问策略默认都是拒绝的，除非有相应的权限名单。这就表明必须使用白名单的形式。&lt;/p&gt;

&lt;h3 id=&#34;6-最小权限原则:af64df5535833d56354a810c9b55c190&#34;&gt;6. 最小权限原则&lt;/h3&gt;

&lt;p&gt;每个角色只能拥有完成任务的最小权限，而且任务完成后要在最短的时间内回收权限。&lt;/p&gt;

&lt;h3 id=&#34;7-清理输出的数据:af64df5535833d56354a810c9b55c190&#34;&gt;7. 清理输出的数据&lt;/h3&gt;

&lt;p&gt;所有从自己系统或者模块发送出去要经过安全过滤保证对其他系统无害。&lt;/p&gt;

&lt;h3 id=&#34;8-纵深防御原则:af64df5535833d56354a810c9b55c190&#34;&gt;8. 纵深防御原则&lt;/h3&gt;

&lt;p&gt;从多个维度或者多个策略同时进行防御，防止攻击源绕过单一的安全策略。&lt;/p&gt;

&lt;h3 id=&#34;9-使用有效的质量保证技术:af64df5535833d56354a810c9b55c190&#34;&gt;9. 使用有效的质量保证技术&lt;/h3&gt;

&lt;p&gt;在开发和测试的各个阶段都需要进行源码审计，fuzz，渗透测试等测试方法来保证代码的质量和功能。&lt;br /&gt;
使用威胁模型来预测软件是否收到威胁。威胁模型包括：识别关键资产，分解应用，识别和分类每项资产或者组件受到的威胁，并基于风险评级排名，然后制定设计方案和代码实现时的防御策略以及实现后的测试用例。&lt;/p&gt;

&lt;h3 id=&#34;10-统一安全编码规范:af64df5535833d56354a810c9b55c190&#34;&gt;10. 统一安全编码规范&lt;/h3&gt;

&lt;p&gt;为开发语言和平台制订安全编码规范，并实施，这样可以减少开发和维护成本，同时能够快速定位缺陷代码。&lt;/p&gt;

&lt;h2 id=&#34;0x3:af64df5535833d56354a810c9b55c190&#34;&gt;0x3&lt;/h2&gt;

&lt;p&gt;编程语言安全开发规范列表&lt;br /&gt;
1. &lt;a href=&#34;http://huangjacky.github.io/post/docs-php-secure-coding/&#34;&gt;PHP安全开发规范&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;0x4-参考索引:af64df5535833d56354a810c9b55c190&#34;&gt;0x4 参考索引&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;[1] &lt;a href=&#34;https://securecoding.cert.org/confluence/display/seccode/Top+10+Secure+Coding+Practices&#34;&gt;cert安全编码规范英文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[2] &lt;a href=&#34;http://staff.ustc.edu.cn/~sycheng/sst/lectures/ch08_Secure_Programming.pdf&#34;&gt;中科大安全编程ppt&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[3] &lt;a href=&#34;https://www.owasp.org/images/7/73/OWASP_SCP_Quick_Reference_Guide_(Chinese).pdf&#34; title=&#34;OWASP_SCP_Quick_Reference_Guide&#34;&gt;OWASP安全编码规范快速参考指南&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>如何在Python中正确的使用BloomFilter</title>
      <link>http://huangjacky.github.io/post/python-bloom-filter/</link>
      <pubDate>Sat, 13 Feb 2016 14:01:35 +0800</pubDate>
      
      <guid>http://huangjacky.github.io/post/python-bloom-filter/</guid>
      <description>

&lt;h2 id=&#34;0x1-什么是布隆过滤器-bloomfilter:09e618735b296f7c44dd000a774e255f&#34;&gt;0x1 什么是布隆过滤器(BloomFilter)&lt;/h2&gt;

&lt;p&gt;1970年，由布隆提出来的一个用于判断元素是否在集合中的高效的算法，集合中的元素可以增加，但是要删除一个元素比较困难，同时还有少量的误报率。&lt;br /&gt;
在数据量比较小的时候，我们可以使用Hash来判断元素是否命中，但是当元素增加起来后，Hash算法需要的空间就会急速增长，查找时间也会增加。布隆过滤器主要用在样本集合量大但是很少有删除元素，不要求100%正确率的场景下。主要有：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;缓存&lt;/li&gt;
&lt;li&gt;计数&lt;/li&gt;
&lt;li&gt;分散聚合&lt;/li&gt;
&lt;li&gt;数据同步&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;算法细节可以查看相关的文档，或者英文的维基中也有详细的介绍。&lt;/p&gt;

&lt;h2 id=&#34;0x2-python中的布隆过滤器:09e618735b296f7c44dd000a774e255f&#34;&gt;0x2 Python中的布隆过滤器&lt;/h2&gt;

&lt;p&gt;Python中有多个实现BloomFilter的包详情可以自己搜索Pypi，本文中主要介绍PyBloom，可以通过pip进行安装。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install pybloom
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;读者也可以去作者的github上直接下载&lt;a href=&#34;https://github.com/jaybaird/python-bloomfilter/&#34;&gt;源码&lt;/a&gt;进行编译安装&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;python setup.py install
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;0x3-使用pybloom:09e618735b296f7c44dd000a774e255f&#34;&gt;0x3 使用PyBloom&lt;/h2&gt;

&lt;p&gt;python-bloomfilter中有两个类&lt;strong&gt;BloomFilter&lt;/strong&gt;和&lt;strong&gt;ScalableBloomFilter&lt;/strong&gt;&lt;br /&gt;
主要的用法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pybloom import BloomFilter, ScalableBloomFilter
bf = BloomFilter(capacity=10000, error_rate=0.001)
bf.add(&#39;test&#39;)
print &#39;test&#39; in bf
sbf = ScalableBloomFilter(mode=ScalableBloomFilter.SMALL_SET_GROWTH)
sbf.add(&#39;dddd&#39;)
print &#39;ddd&#39; in sbf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;BloomFilter是一个定容的过滤器，&lt;strong&gt;error_rate&lt;/strong&gt;是指最大的误报率是0.1%，而ScalableBloomFilter是一个不定容量的布隆过滤器，它可以不断添加元素。&lt;strong&gt;add&lt;/strong&gt;方法是添加元素，如果元素已经在布隆过滤器中，就返回true，如果不在返回fasle并将该元素添加到过滤器中。判断一个元素是否在过滤器中，只需要使用&lt;strong&gt;in&lt;/strong&gt;运算符即可了。&lt;br /&gt;
简单易用的一个Python库，希望对大家有帮助。&lt;/p&gt;

&lt;h2 id=&#34;0x4-参考:09e618735b296f7c44dd000a774e255f&#34;&gt;0x4 参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;[1] &lt;a href=&#34;https://en.wikipedia.org/wiki/Bloom_filter&#34;&gt;Bloom_Filter Wiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[2] &lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8&#34;&gt;布隆过滤器 维基&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[3] &lt;a href=&#34;https://github.com/jaybaird/python-bloomfilter/&#34;&gt;python-bloomfilter&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Hello World</title>
      <link>http://huangjacky.github.io/post/hello/</link>
      <pubDate>Wed, 10 Feb 2016 18:14:49 +0800</pubDate>
      
      <guid>http://huangjacky.github.io/post/hello/</guid>
      <description>

&lt;h1 id=&#34;this-is-my-post:8a07c3dae13f18d0c06cf5f9e482b173&#34;&gt;This is my post.&lt;/h1&gt;

&lt;h2 id=&#34;测试:8a07c3dae13f18d0c06cf5f9e482b173&#34;&gt;测试&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;System.out.println(&amp;quot;hello&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>